<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Unity on メモ帳</title><link>/tags/unity/</link><description>Recent content in Unity on メモ帳</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Mon, 31 Oct 2016 00:00:00 +0000</lastBuildDate><atom:link href="/tags/unity/index.xml" rel="self" type="application/rss+xml"/><item><title>UnityでKinect v2を利用する</title><link>/post/unity%E3%81%A7kinect-v2%E3%82%92%E5%88%A9%E7%94%A8%E3%81%99%E3%82%8B/</link><pubDate>Mon, 31 Oct 2016 00:00:00 +0000</pubDate><guid>/post/unity%E3%81%A7kinect-v2%E3%82%92%E5%88%A9%E7%94%A8%E3%81%99%E3%82%8B/</guid><description>
はじめに UnityでKinect v2を利用するメモ
画像を出したりだとかはいっぱいサンプルあるので単純に人を検出するだけのシンプルなコード
バージョン Unity 5.3 Kinect v2 2.0.1410 必要なライブラリ Kinect v2のSDK（ https://www.microsoft.com/en-us/download/confirmation.aspx?id=44561 ）を入れた上で
http://download.microsoft.com/download/F/8/1/F81BC66F-7AA8-4FE4-8317-26A0991162E9/KinectForWindows_UnityPro_2.0.1410.zip
からUnity用のパッケージを落とす
Kinect.2.0.1410.19000.unitypackageをインポートして全部入れる
ソース 起動と終了時の処理 最低限のコードだけならこんな感じ
Kinect.cs
1using UnityEngine; 2using System.Collections; 3using System.Collections.Generic; 45using Windows.Kinect; 67public class Kinect : MonoBehaviour { 8KinectSensor _Sensor; 9BodyFrameReader _Reader; 10Body[] _Data = null; 1112void Start () { 13_Sensor = KinectSensor.GetDefault(); 14if (_Sensor != null){ 15_Reader = _Sensor.BodyFrameSource.OpenReader(); 16if (!_Sensor.IsOpen){ 17_Sensor.Open(); 18} 19} 20} 2122void OnApplicationQuit(){ 23if (_Reader !</description></item><item><title>Unityでソケットサーバーを建てる</title><link>/post/unity%E3%81%A7%E3%82%BD%E3%82%B1%E3%83%83%E3%83%88%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%92%E5%BB%BA%E3%81%A6%E3%82%8B/</link><pubDate>Sun, 30 Oct 2016 00:00:00 +0000</pubDate><guid>/post/unity%E3%81%A7%E3%82%BD%E3%82%B1%E3%83%83%E3%83%88%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%92%E5%BB%BA%E3%81%A6%E3%82%8B/</guid><description>
はじめに ソケットサーバー作るよ！
Unityでソケット通信したい！って思って調べたらあんまり情報が見つからなかったので泣いた
のでメモ
バージョン Unity 5.3 コード 幾つかポート開けて見たかったので適当に継承して使うクラスを作ってみた
C#良く分からんので指摘があったら是非
try-catch今書いたからおかしいかもしれない
SocketServer.cs
1using UnityEngine; 2using System; 3using System.IO; 4using System.Net; 5using System.Net.Sockets; 6using System.Collections.Generic; 78public class SocketServer : MonoBehaviour { 9TcpListener listener = null; 10List&amp;lt;TcpClient&amp;gt; clients = new List&amp;lt;TcpClient&amp;gt;(); 11readonly object lockObj = new object(); 1213protected void listen(string host, int port){ 14IPAddress ip = IPAddress.Parse(host); 15listener = new TcpListener(ip, port); 16listener.Start(); 17listener.BeginAcceptSocket(OnRequested, listener); 18} 1920public void sendMessage(string msg){ 21if (clients.</description></item><item><title>C#のソケット通信でクライアントが切断したか調べる</title><link>/post/csharp%E3%81%AE%E3%82%BD%E3%82%B1%E3%83%83%E3%83%88%E9%80%9A%E4%BF%A1%E3%81%A7%E3%82%AF%E3%83%A9%E3%82%A4%E3%82%A2%E3%83%B3%E3%83%88%E3%81%8C%E5%88%87%E6%96%AD%E3%81%97%E3%81%9F%E3%81%8B%E8%AA%BF%E3%81%B9%E3%82%8B/</link><pubDate>Mon, 22 Aug 2016 00:00:00 +0000</pubDate><guid>/post/csharp%E3%81%AE%E3%82%BD%E3%82%B1%E3%83%83%E3%83%88%E9%80%9A%E4%BF%A1%E3%81%A7%E3%82%AF%E3%83%A9%E3%82%A4%E3%82%A2%E3%83%B3%E3%83%88%E3%81%8C%E5%88%87%E6%96%AD%E3%81%97%E3%81%9F%E3%81%8B%E8%AA%BF%E3%81%B9%E3%82%8B/</guid><description>
あとで別記事書きますが簡単なソケット通信サーバーを書いた時に困ったのでメモ
クライアントの切断を検知するのにConnectedプロパティを使えば良さそうだなって思って痛い目にあった
信頼と実績のstackoverflowに解決策がありました
How to check if a socket is connected/disconnected in C#? Socketクラスの場合 1Socket client = listener.EndAcceptSocket(ar); 23while (clinet.Connected){ 4byte[] bytes = new byte[256]; 5client.Receive(bytes); 6string s = Encoding.UTF8.GetString(bytes); 78// 何かする 910if ( client.Poll(1000, SelectMode.SelectRead) &amp;amp;&amp;amp; (client.Available == 0) ){ 11break; 12} 13} こんな感じ
余談ですがwhileの外にstring buf = &amp;quot;&amp;quot;;って宣言してその変数に加算代入していくと最初に代入した値しか入ってないんですがバグですかね・・・？
結局TCPClientクラスからNetWorkStream貰ってStreamReaderで取得したんですが
TCPClientクラスの場合 TcpClientのプロパティにClientがあり、ここからSocketクラスが取得出来るのでほぼ一緒です
1TcpListener listener = (TcpListener) ar.AsyncState; 2TcpClient client = listener.EndAcceptTcpClient(ar); 3NetworkStream stream = client.GetStream(); 4StreamReader reader = new StreamReader (stream); 56while (client.</description></item></channel></rss>